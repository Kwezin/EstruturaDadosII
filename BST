public class BST extends BinaryTree {

  public BST() {
    super();
  }

  public BST(Node root) {
    super(root);
  }

  // Pesquisa de um nó baseado no 'id'
  public Node search(int id) {
    return search(root, id);
  }

  private Node search(Node node, int id) {
    if (node == null) {
      return null;
    }

    int diff = id - node.getId();  // Compara pelo 'id' do acidente

    if (diff < 0) {
      return search(node.getLeft(), id);
    } else if (diff > 0) {
      return search(node.getRight(), id);
    } else {
      return node;
    }
  }

  // Inserção de um nó baseado no 'id'
  public void insert(Node newNode) {
    root = insert(root, null, newNode);
  }

  // Método recursivo para inserção que utiliza um Node já criado
  protected Node insert(Node node, Node parent, Node newNode) {
      if (node == null) {
          newNode.setParent(parent); // Define o pai do novo nó
          return newNode;
      }

      int diff = newNode.getId() - node.getId(); // Comparação usando 'id' para evitar duplicatas
      
      if (diff < 0) {
          node.setLeft(insert(node.getLeft(), node, newNode));
      } else if (diff > 0) {
          node.setRight(insert(node.getRight(), node, newNode));
      } else {
          // Caso de duplicata
          throw new RuntimeException("Essa BST não pode ter duplicatas!");
      }

      return node;
  }

  // Remover um nó baseado no 'id'
  public void remove(int id) {
    root = remove(root, id);
  }

  // Método recursivo para remover
  protected Node remove(Node node, int id) {
    if (node == null) {
      throw new RuntimeException("Nó com chave " + id + " não existe na BST!");
    }

    int diff = id - node.getId();  // Comparação pelo 'id'

    if (diff < 0) {
      node.setLeft(remove(node.getLeft(), id));
    } else if (diff > 0) {
      node.setRight(remove(node.getRight(), id));
    } else {
      node = removeNode(node);
    }

    return node;    
  }

  // Método que lida com a remoção real de um nó
  private Node removeNode(Node node) {
    if (node.isLeaf()) {
      return null;
    }

    if (!node.hasLeftChild()) {
      return node.getRight();
    } else if (!node.hasRightChild()) {
      return node.getLeft();
    } else {
      Node predecessor = findPredecessor(node.getId());
      node.setId(predecessor.getId());
      node.setLeft(remove(node.getLeft(), predecessor.getId()));
    }

    return node;    
  }

  // Encontrar o nó com o valor mínimo
  public Node findMin() {
    return findMin(root);
  }

  private Node findMin(Node node) {
    if (node == null) {
      return null;
    }

    while (node.hasLeftChild()) {
      node = node.getLeft();
    }
    return node;
  }

  // Encontrar o nó com o valor máximo
  public Node findMax() {
    return findMax(root);
  }

  private Node findMax(Node node) {
    if (node == null) {
      return null;
    }

    while (node.hasRightChild()) {
      node = node.getRight();
    }
    return node;
  }

  // Encontrar o predecessor de um nó pelo 'id'
  public Node findPredecessor(int id) {
    Node node = search(id);
    return predecessor(node);
  }

  private Node predecessor(Node node) {
    if (node == null) {
      return null;
    }

    if (node.hasLeftChild()) {
      return findMax(node.getLeft());
    } else {
      Node current = node;
      Node parent = node.getParent();

      while (parent != null && current == parent.getLeft()) {
        current = parent;
        parent = current.getParent();
      }

      return parent;
    }
  }

  // Encontrar o sucessor de um nó pelo 'id'
  public Node findSuccessor(int id) {
    Node node = search(id);
    return successor(node);        
  }

  private Node successor(Node node) {
    if (node == null) {
      return null;
    }

    if (node.hasRightChild()) {
      return findMin(node.getRight());
    } else {
      Node current = node;
      Node parent = node.getParent();

      while (parent != null && current == parent.getRight()) {
        current = parent;
        parent = current.getParent();
      }

      return parent;
    }
  }
}
