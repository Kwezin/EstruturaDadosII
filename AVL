public class AVL extends BST {

  public AVL() {
    super();
  }

  public AVL(Node root) {
    super(root);
  }

  // Atualiza as conexões pai-filho ao realizar uma rotação
  private void updateParentChild(Node parent, final Node child, Node newChild) {
    if (parent != null) {
      if (parent.getLeft() == child) {
        parent.setLeft(newChild);
      } else {
        parent.setRight(newChild);
      }
    } else {
      root = newChild;
      newChild.setParent(null);
    }
  }

  // Função para ajustar o balanceamento após uma inserção
  private void rebalance(Node node) {
    while (node != null) {
      node.updateBalanceFactor();

      int balanceFactor = node.getBalanceFactor();

      if (balanceFactor > 1) {
        if (node.getRight().getBalanceFactor() < 0) {
          node.setRight(rotateRight(node.getRight()));
        }
        node = rotateLeft(node);
      } else if (balanceFactor < -1) {
        if (node.getLeft().getBalanceFactor() > 0) {
          node.setLeft(rotateLeft(node.getLeft()));
        }
        node = rotateRight(node);
      }
      node = node.getParent();
    }
  }

  private Node rotateLeft(Node node) {
    if (node == null) return null;

    Node newRoot = node.getRight();
    if (newRoot == null) return null;

    Node parent = node.getParent();
    updateParentChild(parent, node, newRoot);

    Node left = newRoot.getLeft();
    node.setRight(left);

    newRoot.setLeft(node);
    node.updateBalanceFactor();
    newRoot.updateBalanceFactor();

    return newRoot;
  }

  private Node rotateRight(Node node) {
    if (node == null) return null;

    Node newRoot = node.getLeft();
    if (newRoot == null) return null;

    Node parent = node.getParent();
    updateParentChild(parent, node, newRoot);

    Node right = newRoot.getRight();
    node.setLeft(right);

    newRoot.setRight(node);
    node.updateBalanceFactor();
    newRoot.updateBalanceFactor();

    return newRoot;
  }

  // Método insert atualizado, recebendo um Node pronto como argumento
  @Override
  public void insert(Node newNode) {
    root = insert(root, null, newNode);
  }

  // Método recursivo para inserção e balanceamento
  @Override
  protected Node insert(Node node, Node parent, Node newNode) {
    if (node == null) {
      newNode.setParent(parent);
      rebalance(newNode);
      return newNode;
    }

    int diff = newNode.getId() - node.getId();
    System.out.print("\n");
    System.out.print(diff);

    if (diff < 0) {
      node.setLeft(insert(node.getLeft(), node, newNode));
    } else if (diff > 0) {
      node.setRight(insert(node.getRight(), node, newNode));
    } else {
      throw new RuntimeException("Duplicatas não são permitidas.");
    }

    node.updateBalanceFactor();
    rebalance(node);

    return node;
  }

  @Override
  public void remove(int id) {
    root = remove(root, id);
  }

  @Override
  protected Node remove(Node node, int id) {
    if (node == null) {
      throw new RuntimeException("Nó com ID " + id + " não existe na AVL!");
    }

    int diff = id - node.getId();

    if (diff < 0) {
      node.setLeft(remove(node.getLeft(), id));
    } else if (diff > 0) {
      node.setRight(remove(node.getRight(), id));
    } else {
      node = remove(node, id);
    }

    if (node != null) {
      node.updateBalanceFactor();
      rebalance(node);
    }

    return node;
  }
}
